#!/usr/bin/env python3
# coding: utf-8
"""
–ü–æ–ª–Ω—ã–π —Ä–∞–±–æ—á–∏–π Telegram-–±–æ—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏:
- –û–±—â–∏–µ –∏ –≤—ã–µ–∑–¥–Ω—ã–µ –∑–∞–¥–∞—á–∏
- –í—ã–µ–∑–¥–Ω—ã–µ: –≤—ã–±–æ—Ä –∫–ª–∏–µ–Ω—Ç–∞ -> –Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏ -> –∞–¥—Ä–µ—Å -> –æ–ø–∏—Å–∞–Ω–∏–µ -> —Å—Ä–æ–∫
- –û–±—â–∏–µ: –æ–ø–∏—Å–∞–Ω–∏–µ -> —Å—Ä–æ–∫
- –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏: –º–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤ (pdf/jpg/png/heic) –∏–ª–∏ —Ñ–æ—Ç–æ, –∑–∞—Ç–µ–º –Ω–∞–ø–∏—Å–∞—Ç—å "–ì–æ—Ç–æ–≤–æ", –ø–æ—Ç–æ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è
- –§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è —Å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–º–∏ –∏–º–µ–Ω–∞–º–∏ (—É–Ω–∏–∫–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è), —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ –ë–î –≤ JSON
- –ü—Ä–∏ –ø—Ä–æ—Å–º–æ—Ç–µ –∑–∞–¥–∞—á–∏ –±–æ—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –≤—Å–µ –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
- –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∞–º–∏ (–≤—Å—ë —á–µ—Ä–µ–∑ InlineKeyboard)
"""

import os
import json
import logging
import sqlite3
from uuid import uuid4
from datetime import datetime
from typing import List, Optional

from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    InputFile,
)
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

# ---------- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ----------
TOKEN = "8288052246:AAH2HkB5MVqBA8M6gINmLCap0wZ7Fyn8jKY"  # <- –í—Å—Ç–∞–≤—å —Å—é–¥–∞ —Ç–æ–∫–µ–Ω –±–æ—Ç–∞

FILES_DIR = "data_files"  # –ø–∞–ø–∫–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ê–í–† —Ñ–∞–π–ª–æ–≤
os.makedirs(FILES_DIR, exist_ok=True)

# ---------- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ ----------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(name)s %(message)s"
)
logger = logging.getLogger(__name__)

# ---------- –ë–î ----------
DB_PATH = "tasks.db"
conn = sqlite3.connect(DB_PATH, check_same_thread=False)
c = conn.cursor()
# —Å—Ö–µ–º–∞ —Ç–∞–±–ª–∏—Ü—ã: avr - JSON-—Å—Ç—Ä–æ–∫–∞ —Å–ø–∏—Å–∫–∞ –ø—É—Ç–µ–π
c.execute("""CREATE TABLE IF NOT EXISTS tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    type TEXT,
    client TEXT,
    order_number TEXT,
    description TEXT,
    address TEXT,
    deadline TEXT,
    avr TEXT,
    solution TEXT,
    status TEXT
)""")
conn.commit()

# ---------- –°–æ—Å—Ç–æ—è–Ω–∏—è (–≤ user_data['state']) ----------
# 'choose_type', 'choose_client', 'await_order', 'await_address',
# 'await_description', 'await_deadline', 'await_avr', 'await_solution'
# –î–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è: context.user_data['complete_id'], context.user_data['avr_files'] (—Å–ø–∏—Å–æ–∫ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø—É—Ç–µ–π)

# ---------- –†–∞–∑—Ä–µ—à—ë–Ω–Ω—ã–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è ----------
ALLOWED_EXT = (".pdf", ".jpg", ".jpeg", ".png", ".heic")

# ---------- UI (–∫–Ω–æ–ø–∫–∏) ----------
def main_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ûï –ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞", callback_data="new")],
        [InlineKeyboardButton("üìå –¢–µ–∫—É—â–∏–µ –∑–∞–¥–∞—á–∏", callback_data="current"),
         InlineKeyboardButton("üìú –ò—Å—Ç–æ—Ä–∏—è –∑–∞–¥–∞—á", callback_data="history")]
    ])

def type_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üìù –û–±—â–∞—è", callback_data="general"),
         InlineKeyboardButton("üöó –í—ã–µ–∑–¥–Ω–∞—è", callback_data="field")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")]
    ])

def client_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üè¢ –ú–∞–∫—Å–∞–≤–∏—Ç", callback_data="–ú–∞–∫—Å–∞–≤–∏—Ç"),
         InlineKeyboardButton("üè≠ –ì–∞–∑–ø—Ä–æ–º–Ω–µ—Ñ—Ç—å", callback_data="–ì–∞–∑–ø—Ä–æ–º–Ω–µ—Ñ—Ç—å")],
        [InlineKeyboardButton("üëó –ì–ª–æ—Ä–∏—è –î–∂–∏–Ω—Å", callback_data="–ì–ª–æ—Ä–∏—è –î–∂–∏–Ω—Å"),
         InlineKeyboardButton("üõí –ü–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫", callback_data="–ü–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫")],
        [InlineKeyboardButton("‚õΩ –¢–µ–±–æ–π–ª", callback_data="–¢–µ–±–æ–π–ª"),
         InlineKeyboardButton("‚õΩ –¢–∞—Ç–Ω–µ—Ñ—Ç—å", callback_data="–¢–∞—Ç–Ω–µ—Ñ—Ç—å")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")]
    ])

def confirm_delete_kb(tid: int) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ùå –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ", callback_data=f"confirm_delete_{tid}")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data=f"open_{tid}")]
    ])

# ---------- –£—Ç–∏–ª–∏—Ç—ã ----------
def unique_filename(original_name: str) -> str:
    """–î–æ–±–∞–≤–ª—è–µ—Ç uuid —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–ª–ª–∏–∑–∏–π"""
    base = os.path.basename(original_name)
    uid = uuid4().hex[:8]
    return f"{uid}_{base}"

def save_document_file(file_obj, suggested_name: Optional[str] = None) -> str:
    """
    file_obj: telegram File object (–ø–æ–ª—É—á–µ–Ω–Ω—ã–π —á–µ—Ä–µ–∑ get_file() –∏–ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç/—Ñ–æ—Ç–æ)
    suggested_name: –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–º—è (–µ—Å–ª–∏ –µ—Å—Ç—å)
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
    """
    if suggested_name:
        fname = unique_filename(suggested_name)
    else:
        fname = f"{uuid4().hex}.bin"
    path = os.path.join(FILES_DIR, fname)
    # download_to_drive –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ –±–æ—Ç-–æ–∫—Ä—É–∂–µ–Ω–∏–∏; –∏—Å–ø–æ–ª—å–∑—É–µ–º telegram-file.download_to_drive
    # file_obj –∑–¥–µ—Å—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–±—ä–µ–∫—Ç, —É –∫–æ—Ç–æ—Ä–æ–≥–æ –µ—Å—Ç—å coroutine download_to_drive
    # –≤—ã–∑–æ–≤ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å await file_obj.download_to_drive(path) –∏–∑ async-–∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
    return path  # —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –≤ –≤—ã–∑—ã–≤–∞—é—â–µ–º –∫–æ–¥–µ

def task_label_row(tid: int, ttype: str, client: Optional[str], addr: Optional[str], description: Optional[str]) -> str:
    if ttype == "field":
        return f"#{tid} {client} | {addr}"
    else:
        return f"#{tid} { (description or '')[:30] }..."

# ---------- –•–µ–Ω–¥–ª–µ—Ä—ã ----------

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info("User %s started bot", update.effective_user.id)
    context.user_data.clear()
    await update.message.reply_text("üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏.", reply_markup=main_menu())

# --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é (new/current/history/back_main) ---
async def menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    uid = query.from_user.id
    logger.info("menu_callback %s from user %s", data, uid)

    if data == "new":
        # –Ω–∞—á–∏–Ω–∞–µ–º –¥–∏–∞–ª–æ–≥
        context.user_data.clear()
        context.user_data['state'] = 'choose_type'
        await query.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∑–∞–¥–∞—á–∏:", reply_markup=type_menu())
        return

    if data == "current":
        c.execute("SELECT id, type, client, address, description FROM tasks WHERE status='active' ORDER BY id DESC")
        rows = c.fetchall()
        if not rows:
            await query.message.reply_text("üì≠ –ù–µ—Ç —Ç–µ–∫—É—â–∏—Ö –∑–∞–¥–∞—á.", reply_markup=main_menu())
            return
        kb = []
        for tid, ttype, client, addr, desc in rows:
            label = task_label_row(tid, ttype, client, addr, desc)
            kb.append([InlineKeyboardButton(f"üîé {label}", callback_data=f"open_{tid}")])
        kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
        await query.message.reply_text("üìå –¢–µ–∫—É—â–∏–µ –∑–∞–¥–∞—á–∏:", reply_markup=InlineKeyboardMarkup(kb))
        return

    if data == "history":
        c.execute("SELECT id, type, client, address, description FROM tasks WHERE status='done' ORDER BY id DESC LIMIT 50")
        rows = c.fetchall()
        if not rows:
            await query.message.reply_text("üì≠ –ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.", reply_markup=main_menu())
            return
        kb = []
        for tid, ttype, client, addr, desc in rows:
            label = task_label_row(tid, ttype, client, addr, desc)
            kb.append([InlineKeyboardButton(f"üìú {label}", callback_data=f"open_{tid}")])
        kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
        await query.message.reply_text("üìú –ò—Å—Ç–æ—Ä–∏—è –∑–∞–¥–∞—á:", reply_markup=InlineKeyboardMarkup(kb))
        return

    if data == "back_main":
        context.user_data.clear()
        await query.message.edit_text("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=main_menu())
        return

# --- –ö–Ω–æ–ø–∫–∏ –¥–∏–∞–ª–æ–≥–∞ (–≤—ã–±–æ—Ä —Ç–∏–ø–∞, –≤—ã–±–æ—Ä –∫–ª–∏–µ–Ω—Ç–∞, open/complete/delete/confirm_delete) ---
async def dialog_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    state = context.user_data.get('state')
    uid = query.from_user.id
    logger.info("dialog_buttons data=%s state=%s user=%s", data, state, uid)

    # –ï—Å–ª–∏ –æ–∂–∏–¥–∞–µ—Ç—Å—è –≤—ã–±–æ—Ä —Ç–∏–ø–∞
    if state == 'choose_type' and data in ('general', 'field'):
        context.user_data['type'] = data
        if data == 'field':
            context.user_data['state'] = 'choose_client'
            await query.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∏–µ–Ω—Ç–∞:", reply_markup=client_menu())
            return
        else:
            context.user_data['state'] = 'await_description'
            await query.message.edit_text("–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:")
            return

    # –ï—Å–ª–∏ –æ–∂–∏–¥–∞–µ—Ç—Å—è –≤—ã–±–æ—Ä –∫–ª–∏–µ–Ω—Ç–∞
    if state == 'choose_client':
        # data —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–º—è –∫–ª–∏–µ–Ω—Ç–∞
        context.user_data['client'] = data
        context.user_data['state'] = 'await_order'
        await query.message.edit_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏:")
        return

    # –û—Ç–∫—Ä—ã—Ç–∏–µ/–∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ/—É–¥–∞–ª–µ–Ω–∏–µ/–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ ‚Äî –ø–µ—Ä–µ–∞–¥—Ä–µ—Å—É–µ–º
    if data.startswith("open_"):
        await open_task(update, context)
        return
    if data.startswith("complete_"):
        await complete_task(update, context)
        return
    if data.startswith("delete_"):
        await delete_task(update, context)
        return
    if data.startswith("confirm_delete_"):
        await confirm_delete(update, context)
        return

    logger.warning("Unhandled dialog button: %s (state=%s)", data, state)

# --- –¢–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è: –º–∞—Ä—à—Ä—É—Ç–∏–∑–∏—Ä—É–µ–º –ø–æ context.user_data['state'] ---
async def text_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip()
    uid = update.effective_user.id
    state = context.user_data.get('state')
    logger.info("text_message user=%s state=%s text=%s", uid, state, text[:60])

    # –µ—Å–ª–∏ –Ω–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è ‚Äî –ø–æ–¥—Å–∫–∞–∑–∫–∞
    if not state:
        await update.message.reply_text("–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤ –º–µ–Ω—é.", reply_markup=main_menu())
        return

    # –û–∂–∏–¥–∞–µ–º –Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏ (–≤—ã–µ–∑–¥–Ω–∞—è)
    if state == 'await_order':
        context.user_data['order_number'] = text
        context.user_data['state'] = 'await_address'
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å:")
        return

    # –û–∂–∏–¥–∞–µ–º –∞–¥—Ä–µ—Å (–≤—ã–µ–∑–¥–Ω–∞—è)
    if state == 'await_address':
        context.user_data['address'] = text
        context.user_data['state'] = 'await_description'
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:")
        return

    # –û–∂–∏–¥–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ (–æ–±—â–∞—è –∏–ª–∏ –≤—ã–µ–∑–¥–Ω–∞—è)
    if state == 'await_description':
        context.user_data['description'] = text
        context.user_data['state'] = 'await_deadline'
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Å—Ä–æ–∫ (–î–î.MM.–ì–ì –ß–ß:–ú–ú):")
        return

    # –û–∂–∏–¥–∞–µ–º —Å—Ä–æ–∫ ‚Äî —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–¥–∞—á—É –∏ –∑–∞–∫—Ä—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥
    if state == 'await_deadline':
        # –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏—é —Ñ–æ—Ä–º–∞—Ç–∞ –¥–∞—Ç—ã ‚Äî –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
        deadline_text = text
        user_data_snapshot = dict(context.user_data)  # –∫–æ–ø–∏—Ä—É–µ–º
        try:
            c.execute("""INSERT INTO tasks (user_id, type, client, order_number, description, address, deadline, status)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                      (uid,
                       user_data_snapshot.get('type'),
                       user_data_snapshot.get('client'),
                       user_data_snapshot.get('order_number'),
                       user_data_snapshot.get('description'),
                       user_data_snapshot.get('address'),
                       deadline_text,
                       "active"))
            conn.commit()
            tid = c.lastrowid
            logger.info("Task created id=%s by user=%s", tid, uid)
        except Exception as e:
            logger.exception("DB insert failed")
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {e}", reply_markup=main_menu())
            context.user_data.clear()
            return

        context.user_data.clear()
        await update.message.reply_text(f"‚úÖ –ó–∞–¥–∞—á–∞ #{tid} –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ —Ç–µ–∫—É—â–∏–µ!", reply_markup=main_menu())
        return

    # –ï—Å–ª–∏ –æ–∂–∏–¥–∞–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–∫–æ–Ω—á–∏–ª –∑–∞–≥—Ä—É–∂–∞—Ç—å —Ñ–∞–π–ª—ã –∏ –ø–∏—à–µ—Ç "–ì–æ—Ç–æ–≤–æ" (–≤ –ø—Ä–æ—Ü–µ—Å—Å–µ complete)
    if state == 'await_avr' and text.lower() in ("–≥–æ—Ç–æ–≤–æ", "–≥–æ—Ç–æ–≤–æ."):
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –≤ –ë–î
        tid = context.user_data.get('complete_id')
        avr_list = context.user_data.get('avr_files', [])
        try:
            avr_json = json.dumps(avr_list, ensure_ascii=False)
            c.execute("UPDATE tasks SET avr=? WHERE id=?", (avr_json, tid))
            conn.commit()
            context.user_data['state'] = 'await_solution'
            await update.message.reply_text("‚úÖ –§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã. –¢–µ–ø–µ—Ä—å –æ–ø–∏—à–∏—Ç–µ —Ä–µ—à–µ–Ω–∏–µ (–∫–æ—Ä–æ—Ç–∫–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ).")
            return
        except Exception as e:
            logger.exception("Failed to store avr list")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.", reply_markup=main_menu())
            context.user_data.clear()
            return

    # –ï—Å–ª–∏ –æ–∂–∏–¥–∞–µ–º —Ç–µ–∫—Å—Ç —Ä–µ—à–µ–Ω–∏—è
    if state == 'await_solution':
        tid = context.user_data.get('complete_id')
        if not tid:
            await update.message.reply_text("‚ùå –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: id –∑–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.", reply_markup=main_menu())
            context.user_data.clear()
            return
        solution_text = text
        try:
            c.execute("UPDATE tasks SET solution=?, status=? WHERE id=?", (solution_text, "done", tid))
            conn.commit()
            await update.message.reply_text(f"‚úÖ –ó–∞–¥–∞—á–∞ #{tid} –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∏ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é!", reply_markup=main_menu())
            context.user_data.clear()
            return
        except Exception as e:
            logger.exception("Failed to update solution")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ä–µ—à–µ–Ω–∏—è.", reply_markup=main_menu())
            context.user_data.clear()
            return

    # –í–æ –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö ‚Äî –ø–æ–¥—Å–∫–∞–∑–∫–∞
    await update.message.reply_text("–Ø –Ω–µ –æ–∂–∏–¥–∞–ª —ç—Ç–æ—Ç –≤–≤–æ–¥. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤ –º–µ–Ω—é.", reply_markup=main_menu())

# --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –∏ —Ñ–æ—Ç–æ (–¥–ª—è –ê–í–†) ---
async def document_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    state = context.user_data.get('state')
    logger.info("document_handler user=%s state=%s", uid, state)

    # —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –º—ã –æ–∂–∏–¥–∞–µ–º –ê–í–†-—Ñ–∞–π–ª—ã
    if state != 'await_avr':
        await update.message.reply_text("–Ø —Å–µ–π—á–∞—Å –Ω–µ –æ–∂–∏–¥–∞—é —Ñ–∞–π–ª. –ù–∞–∂–º–∏—Ç–µ –º–µ–Ω—é.", reply_markup=main_menu())
        return

    tid = context.user_data.get('complete_id')
    if not tid:
        await update.message.reply_text("‚ùå –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: id –∑–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.", reply_markup=main_menu())
        context.user_data.clear()
        return

    # –î–æ–∫—É–º–µ–Ω—Ç (–≤–∫–ª—é—á–∞—è HEIC/PDF)
    if update.message.document:
        doc = update.message.document
        # –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
        fname = doc.file_name or f"avr_{tid}"
        _, ext = os.path.splitext(fname)
        ext = ext.lower()
        if ext not in ALLOWED_EXT:
            await update.message.reply_text("‚ö†Ô∏è –†–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ PDF/JPG/PNG/HEIC.")
            return
        tg_file = await doc.get_file()
        saved_name = unique_filename(fname)
        path = os.path.join(FILES_DIR, saved_name)
        await tg_file.download_to_drive(path)
        context.user_data.setdefault('avr_files', []).append(path)
        await update.message.reply_text(f"‚úÖ –§–∞–π–ª {fname} —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –ü—Ä–∏—à–ª–∏—Ç–µ –µ—â—ë –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ì–æ—Ç–æ–≤–æ'.")

        return

    # –§–æ—Ç–æ (telegram –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç list of PhotoSize)
    if update.message.photo:
        photo = update.message.photo[-1]  # –ª—É—á—à–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ
        tg_file = await photo.get_file()
        # —Å—Ç—Ä–æ–∏–º –∏–º—è
        saved_name = unique_filename(f"{photo.file_unique_id}.jpg")
        path = os.path.join(FILES_DIR, saved_name)
        await tg_file.download_to_drive(path)
        context.user_data.setdefault('avr_files', []).append(path)
        await update.message.reply_text("‚úÖ –§–æ—Ç–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ. –ü—Ä–∏—à–ª–∏—Ç–µ –µ—â—ë –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ì–æ—Ç–æ–≤–æ'.")
        return

    # –ò–Ω–∞—á–µ
    await update.message.reply_text("–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø —Ñ–∞–π–ª–∞. –†–∞–∑—Ä–µ—à–µ–Ω—ã: PDF, JPG, PNG, HEIC –∏ —Ñ–æ—Ç–æ.")

# --- –û—Ç–∫—Ä—ã—Ç–∏–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –∑–∞–¥–∞—á–∏ (open_N) ---
async def open_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    # allow both callback and direct call
    if query:
        await query.answer()
        data = query.data
        tid = int(data.split("_")[1])
        logger.info("open_task tid=%s by user=%s", tid, query.from_user.id)
        c.execute("SELECT * FROM tasks WHERE id=?", (tid,))
        row = c.fetchone()
        if not row:
            await query.message.reply_text("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", reply_markup=main_menu())
            return

        # unpack row
        _, user_id, ttype, client, order, desc, addr, deadline, avr_json, sol, status = row
        msg_lines = []
        msg_lines.append(f"üÜî <b>–ó–∞–¥–∞—á–∞ #{tid}</b>")
        msg_lines.append(f"üìå <b>–¢–∏–ø:</b> {'üöó –í—ã–µ–∑–¥–Ω–∞—è' if ttype == 'field' else 'üìù –û–±—â–∞—è'}")
        if client:
            msg_lines.append(f"üè¢ <b>–ö–ª–∏–µ–Ω—Ç:</b> {client}")
        if order:
            msg_lines.append(f"‚Ññ <b>–ó–∞—è–≤–∫–∏:</b> {order}")
        if desc:
            msg_lines.append(f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> {desc}")
        if addr:
            msg_lines.append(f"üìç <b>–ê–¥—Ä–µ—Å:</b> {addr}")
            msg_lines.append(f"üîó <a href='https://yandex.ru/maps/?text={addr}'>–û—Ç–∫—Ä—ã—Ç—å –≤ –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç–∞—Ö</a>")
        msg_lines.append(f"‚è∞ <b>–°—Ä–æ–∫:</b> {deadline}")
        msg_lines.append(f"üìä <b>–°—Ç–∞—Ç—É—Å:</b> {'‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞' if status == 'done' else 'üïí –ê–∫—Ç–∏–≤–Ω–∞'}")
        if status == 'done' and sol:
            msg_lines.append(f"üìù <b>–†–µ—à–µ–Ω–∏–µ:</b> {sol}")

        keyboard = []
        if status != 'done':
            keyboard.append([InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data=f"complete_{tid}")])
        keyboard.append([InlineKeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"delete_{tid}")])
        keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])

        await query.message.reply_text("\n".join(msg_lines), parse_mode="HTML", reply_markup=InlineKeyboardMarkup(keyboard), disable_web_page_preview=True)

        # –µ—Å–ª–∏ –µ—Å—Ç—å avr —Ñ–∞–π–ª—ã ‚Äî –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏—Ö (–ø–æ—Å–ª–µ —Ç–µ–∫—Å—Ç–∞)
        if avr_json:
            try:
                avr_list = json.loads(avr_json)
                for fpath in avr_list:
                    if os.path.isfile(fpath):
                        try:
                            await query.message.reply_document(document=InputFile(fpath), caption="üìé –ê–í–†")
                        except Exception:
                            # –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–∞–∫ –¥–æ–∫—É–º–µ–Ω—Ç, –ø–æ–ø—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–∞–∫ —Ñ–∞–π–ª –±–µ–∑ InputFile
                            try:
                                await query.message.reply_document(document=open(fpath, "rb"))
                            except Exception:
                                logger.exception("Failed to send file %s", fpath)
                    else:
                        logger.warning("File not found: %s", fpath)
            except Exception:
                logger.exception("Failed to parse avr_json or send files")

        return

    # –ï—Å–ª–∏ –≤—ã–∑–≤–∞–ª–∏ –±–µ–∑ callback ‚Äî –ø–æ–¥—Å–∫–∞–∑–∫–∞
    await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –∑–∞–¥–∞—á–∏.", reply_markup=main_menu())

# --- –ù–∞—á–∞–ª–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏ (–ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ "–ó–∞–≤–µ—Ä—à–∏—Ç—å") ---
async def complete_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    tid = int(data.split("_")[1])
    context.user_data.clear()
    context.user_data['complete_id'] = tid
    context.user_data['state'] = 'await_avr'
    context.user_data['avr_files'] = []
    logger.info("User %s begins completion of task %s", query.from_user.id, tid)
    await query.message.reply_text(
        "üìé –ü—Ä–∏–∫—Ä–µ–ø–∏—Ç–µ —Ñ–∞–π–ª—ã –ê–í–† (pdf/jpg/png/heic) –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ.\n"
        "–ú–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–¥—Ä—è–¥.\n"
        "–ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ ‚Äî –Ω–∞–ø–∏—à–∏—Ç–µ '–ì–æ—Ç–æ–≤–æ'."
    )

# --- –£–¥–∞–ª–µ–Ω–∏–µ ---
async def delete_task(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    tid = int(query.data.split("_")[1])
    logger.info("User %s requested delete for task %s", query.from_user.id, tid)
    await query.message.reply_text(f"‚ö†Ô∏è –£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É #{tid}?", reply_markup=confirm_delete_kb(tid))

async def confirm_delete(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    parts = query.data.split("_")
    if len(parts) >= 3:
        tid = int(parts[2])
        try:
            c.execute("DELETE FROM tasks WHERE id=?", (tid,))
            conn.commit()
            # optionally remove files from disk? we won't auto-delete files to be safe
            logger.info("Task %s deleted by user %s", tid, query.from_user.id)
            await query.message.reply_text(f"üóë –ó–∞–¥–∞—á–∞ #{tid} —É–¥–∞–ª–µ–Ω–∞.", reply_markup=main_menu())
        except Exception as e:
            logger.exception("Failed to delete task")
            await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏.", reply_markup=main_menu())
    else:
        await query.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞.", reply_markup=main_menu())

# --- –ö–æ–º–∞–Ω–¥–∞ /task <id> (–æ—Ç–∫—Ä—ã—Ç—å –∑–∞–¥–∞—á—É –ø–æ id) ---
async def cmd_task_by_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    args = context.args
    if not args:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /task <id>")
        return
    try:
        tid = int(args[0])
    except ValueError:
        await update.message.reply_text("ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
        return

    # —Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø—Å–µ–≤–¥–æ-callback: –Ω–∞–π–¥—ë–º –∑–∞–¥–∞—á—É –∏ –≤—ã–≤–µ–¥–µ–º —Ç–∞–∫ –∂–µ, –∫–∞–∫ open_task
    c.execute("SELECT * FROM tasks WHERE id=?", (tid,))
    row = c.fetchone()
    if not row:
        await update.message.reply_text("–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", reply_markup=main_menu())
        return

    # –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º –ª–æ–≥–∏–∫—É —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞
    _, user_id, ttype, client, order, desc, addr, deadline, avr_json, sol, status = row
    msg_lines = []
    msg_lines.append(f"üÜî <b>–ó–∞–¥–∞—á–∞ #{tid}</b>")
    msg_lines.append(f"üìå <b>–¢–∏–ø:</b> {'üöó –í—ã–µ–∑–¥–Ω–∞—è' if ttype == 'field' else 'üìù –û–±—â–∞—è'}")
    if client:
        msg_lines.append(f"üè¢ <b>–ö–ª–∏–µ–Ω—Ç:</b> {client}")
    if order:
        msg_lines.append(f"‚Ññ <b>–ó–∞—è–≤–∫–∏:</b> {order}")
    if desc:
        msg_lines.append(f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> {desc}")
    if addr:
        msg_lines.append(f"üìç <b>–ê–¥—Ä–µ—Å:</b> {addr}")
        msg_lines.append(f"üîó <a href='https://yandex.ru/maps/?text={addr}'>–û—Ç–∫—Ä—ã—Ç—å –≤ –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç–∞—Ö</a>")
    msg_lines.append(f"‚è∞ <b>–°—Ä–æ–∫:</b> {deadline}")
    msg_lines.append(f"üìä <b>–°—Ç–∞—Ç—É—Å:</b> {'‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞' if status == 'done' else 'üïí –ê–∫—Ç–∏–≤–Ω–∞'}")
    if status == 'done' and sol:
        msg_lines.append(f"üìù <b>–†–µ—à–µ–Ω–∏–µ:</b> {sol}")

    keyboard = []
    if status != 'done':
        keyboard.append([InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data=f"complete_{tid}")])
    keyboard.append([InlineKeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"delete_{tid}")])
    keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])

    await update.message.reply_text("\n".join(msg_lines), parse_mode="HTML", reply_markup=InlineKeyboardMarkup(keyboard), disable_web_page_preview=True)

    if avr_json:
        try:
            avr_list = json.loads(avr_json)
            for fpath in avr_list:
                if os.path.isfile(fpath):
                    await update.message.reply_document(document=InputFile(fpath), caption="üìé –ê–í–†")
        except Exception:
            logger.exception("Failed to send AVR files for /task")

# ---------- –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ----------
def main():
    if TOKEN == "–í–ê–®_–¢–û–ö–ï–ù" or not TOKEN:
        raise SystemExit("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–ø–∏—à–∏—Ç–µ —Ç–æ–∫–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π TOKEN –≤ –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞.")

    app = Application.builder().token(TOKEN).build()

    # –ö–æ–º–∞–Ω–¥—ã
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("task", cmd_task_by_id))  # /task <id>

    # –ö–Ω–æ–ø–∫–∏ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
    app.add_handler(CallbackQueryHandler(menu_callback, pattern="^(new|current|history|back_main)$"))

    # –î–∏–∞–ª–æ–≥–æ–≤—ã–µ –∫–Ω–æ–ø–∫–∏ (—Ç–∏–ø/–∫–ª–∏–µ–Ω—Ç) + open/complete/delete/confirm_delete
    app.add_handler(CallbackQueryHandler(dialog_buttons,
                                        pattern="^(general|field|–ú–∞–∫—Å–∞–≤–∏—Ç|–ì–∞–∑–ø—Ä–æ–º–Ω–µ—Ñ—Ç—å|–ì–ª–æ—Ä–∏—è –î–∂–∏–Ω—Å|–ü–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫|–¢–µ–±–æ–π–ª|–¢–∞—Ç–Ω–µ—Ñ—Ç—å|open_\\d+|complete_\\d+|delete_\\d+|confirm_delete_\\d+)$"))

    # –î–ª—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç–∏ —Ç–∞–∫–∂–µ –æ—Ç–¥–µ–ª—å–Ω–æ –¥–æ–±–∞–≤–∏–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∑–∞–¥–∞—á
    app.add_handler(CallbackQueryHandler(open_task, pattern=r"^open_\d+$"))
    app.add_handler(CallbackQueryHandler(complete_task, pattern=r"^complete_\d+$"))
    app.add_handler(CallbackQueryHandler(delete_task, pattern=r"^delete_\d+$"))
    app.add_handler(CallbackQueryHandler(confirm_delete, pattern=r"^confirm_delete_\d+$"))

    # –¢–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è (–≤–µ—Å—å –¥–∏–∞–ª–æ–≥ –º–∞—Ä—à—Ä—É—Ç–∏–∑–∏—Ä—É–µ—Ç—Å—è —Å—é–¥–∞)
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, text_message_handler))

    # –î–æ–∫—É–º–µ–Ω—Ç—ã –∏ —Ñ–æ—Ç–æ ‚Äî –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ê–í–†
    app.add_handler(MessageHandler(filters.Document.ALL | filters.PHOTO, document_handler))

    logger.info("Bot starting...")
    app.run_polling()

if __name__ == "__main__":
    main()
