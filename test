#!/usr/bin/env python3
# coding: utf-8

import os
import json
import sqlite3
import logging
from uuid import uuid4
from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, InputFile
)
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler,
    MessageHandler, filters, ContextTypes
)

# --------------- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ---------------
TOKEN = "8288052246:AAH2HkB5MVqBA8M6gINmLCap0wZ7Fyn8jKY"  # <- –ø–æ—Å—Ç–∞–≤—å —Ç–æ–∫–µ–Ω
FILES_DIR = "avr_files"
os.makedirs(FILES_DIR, exist_ok=True)

# --------------- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ ---------------
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger(__name__)

# --------------- –ë–î ---------------
conn = sqlite3.connect("tasks.db", check_same_thread=False)
c = conn.cursor()
c.execute("""CREATE TABLE IF NOT EXISTS tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    type TEXT,
    client TEXT,
    order_number TEXT,
    description TEXT,
    address TEXT,
    deadline TEXT,
    avr TEXT,         -- JSON string: [{"path": "...", "name": "..."}]
    solution TEXT,
    status TEXT
)""")
conn.commit()

# --------------- UI-–∫–Ω–æ–ø–∫–∏ ---------------
def main_menu():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ûï –ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞", callback_data="new")],
        [InlineKeyboardButton("üìå –¢–µ–∫—É—â–∏–µ –∑–∞–¥–∞—á–∏", callback_data="current"),
         InlineKeyboardButton("üìú –ò—Å—Ç–æ—Ä–∏—è –∑–∞–¥–∞—á", callback_data="history")]
    ])

def type_menu():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üìù –û–±—â–∞—è", callback_data="general"),
         InlineKeyboardButton("üöó –í—ã–µ–∑–¥–Ω–∞—è", callback_data="field")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")]
    ])

def client_menu():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üè¢ –ú–∞–∫—Å–∞–≤–∏—Ç", callback_data="–ú–∞–∫—Å–∞–≤–∏—Ç"),
         InlineKeyboardButton("üè≠ –ì–∞–∑–ø—Ä–æ–º–Ω–µ—Ñ—Ç—å", callback_data="–ì–∞–∑–ø—Ä–æ–º–Ω–µ—Ñ—Ç—å")],
        [InlineKeyboardButton("üëó –ì–ª–æ—Ä–∏—è –î–∂–∏–Ω—Å", callback_data="–ì–ª–æ—Ä–∏—è –î–∂–∏–Ω—Å"),
         InlineKeyboardButton("üõí –ü–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫", callback_data="–ü–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫")],
        [InlineKeyboardButton("‚õΩ –¢–µ–±–æ–π–ª", callback_data="–¢–µ–±–æ–π–ª"),
         InlineKeyboardButton("‚õΩ –¢–∞—Ç–Ω–µ—Ñ—Ç—å", callback_data="–¢–∞—Ç–Ω–µ—Ñ—Ç—å")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")]
    ])

def confirm_delete_kb(tid: int):
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ùå –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ", callback_data=f"confirm_delete_{tid}")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data=f"open_{tid}")]
    ])

# --------------- –£—Ç–∏–ª–∏—Ç—ã ---------------
def uniq_name(original: str) -> str:
    base = os.path.basename(original)
    uid = uuid4().hex[:8]
    return f"{uid}_{base}"

# --------------- –•–µ–Ω–¥–ª–µ—Ä—ã ---------------

async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    await update.message.reply_text("üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏.", reply_markup=main_menu())

# –ì–ª–∞–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏: new/current/history/back
async def main_buttons_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    user = query.from_user.id
    logger.info("main button %s by %s", data, user)

    if data == "new":
        context.user_data.clear()
        context.user_data["state"] = "choose_type"
        await query.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∑–∞–¥–∞—á–∏:", reply_markup=type_menu())
        return

    if data == "current":
        c.execute("SELECT id, type, client, address, description FROM tasks WHERE status='active' ORDER BY id DESC")
        rows = c.fetchall()
        if not rows:
            await query.message.reply_text("üì≠ –ù–µ—Ç —Ç–µ–∫—É—â–∏—Ö –∑–∞–¥–∞—á.", reply_markup=main_menu())
            return
        kb = []
        for tid, ttype, client, addr, desc in rows:
            label = f"#{tid} {client} | {addr}" if ttype == "field" else f"#{tid} { (desc or '')[:30] }..."
            kb.append([InlineKeyboardButton(f"üîé {label}", callback_data=f"open_{tid}")])
        kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
        await query.message.reply_text("üìå –¢–µ–∫—É—â–∏–µ –∑–∞–¥–∞—á–∏:", reply_markup=InlineKeyboardMarkup(kb))
        return

    if data == "history":
        c.execute("SELECT id, type, client, address, description FROM tasks WHERE status='done' ORDER BY id DESC LIMIT 50")
        rows = c.fetchall()
        if not rows:
            await query.message.reply_text("üì≠ –ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.", reply_markup=main_menu())
            return
        kb = []
        for tid, ttype, client, addr, desc in rows:
            label = f"#{tid} {client} | {addr}" if ttype == "field" else f"#{tid} { (desc or '')[:30] }..."
            kb.append([InlineKeyboardButton(f"üìú {label}", callback_data=f"open_{tid}")])
        kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
        await query.message.reply_text("üìú –ò—Å—Ç–æ—Ä–∏—è –∑–∞–¥–∞—á:", reply_markup=InlineKeyboardMarkup(kb))
        return

    if data == "back_main":
        context.user_data.clear()
        await query.message.edit_text("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=main_menu())
        return

# –î–∏–∞–ª–æ–≥–æ–≤—ã–µ –∏ —Å–ª—É–∂–µ–±–Ω—ã–µ –∫–Ω–æ–ø–∫–∏: –≤—ã–±–æ—Ä —Ç–∏–ø–∞/–∫–ª–∏–µ–Ω—Ç–∞, open/complete/delete/confirm_delete, avr_done
async def callback_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    state = context.user_data.get("state")
    user = query.from_user.id
    logger.info("callback_router data=%s state=%s user=%s", data, state, user)

    # –≤—ã–±–æ—Ä —Ç–∏–ø–∞
    if state == "choose_type" and data in ("general", "field"):
        context.user_data["type"] = data
        if data == "field":
            context.user_data["state"] = "choose_client"
            await query.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∏–µ–Ω—Ç–∞:", reply_markup=client_menu())
            return
        else:
            context.user_data["state"] = "await_description"
            await query.message.edit_text("–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:")
            return

    # –≤—ã–±–æ—Ä –∫–ª–∏–µ–Ω—Ç–∞
    if state == "choose_client" and data in ("–ú–∞–∫—Å–∞–≤–∏—Ç","–ì–∞–∑–ø—Ä–æ–º–Ω–µ—Ñ—Ç—å","–ì–ª–æ—Ä–∏—è –î–∂–∏–Ω—Å","–ü–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫","–¢–µ–±–æ–π–ª","–¢–∞—Ç–Ω–µ—Ñ—Ç—å"):
        context.user_data["client"] = data
        context.user_data["state"] = "await_order"
        await query.message.edit_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏:")
        return

    # –æ—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É
    if data.startswith("open_"):
        await open_task_callback(update, context)
        return

    # –Ω–∞—á–∞—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
    if data.startswith("complete_"):
        await start_complete_callback(update, context)
        return

    # —É–¥–∞–ª–∏—Ç—å
    if data.startswith("delete_"):
        await delete_task_callback(update, context)
        return

    # –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ
    if data.startswith("confirm_delete_"):
        await confirm_delete_callback(update, context)
        return

    # –≥–æ—Ç–æ–≤–æ ‚Äî –∫–Ω–æ–ø–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ê–í–†
    if data == "avr_done":
        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º avr list –∏–∑ context.user_data –∏ –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ –æ–∂–∏–¥–∞–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è
        tid = context.user_data.get("complete_id")
        if not tid:
            await query.message.reply_text("‚ùå –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: id –∑–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            context.user_data.clear()
            return
        avr_files = context.user_data.get("avr_files", [])
        try:
            avr_json = json.dumps(avr_files, ensure_ascii=False)
            c.execute("UPDATE tasks SET avr=? WHERE id=?", (avr_json, tid))
            conn.commit()
            context.user_data["state"] = "await_solution"
            await query.message.reply_text("‚úÖ –§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã. –¢–µ–ø–µ—Ä—å –æ–ø–∏—à–∏—Ç–µ —Ä–µ—à–µ–Ω–∏–µ (–∫–æ—Ä–æ—Ç–∫–æ):")
        except Exception as e:
            logger.exception("Failed to save avr")
            await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–æ–≤.")
            context.user_data.clear()
        return

    # –∫–Ω–æ–ø–∫–∞ –æ—Ç–º–µ–Ω—ã –≤ –¥–∏–∞–ª–æ–≥–µ (–æ—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É —Å–Ω–æ–≤–∞)
    if data.startswith("open_") or data == "back_main":
        # handled above or by main_buttons_callback
        return

    # –µ—Å–ª–∏ –ø–æ–ø–∞–ª–∏ —Å—é–¥–∞ ‚Äî –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è callback
    logger.warning("Unhandled callback: %s", data)
    await query.message.reply_text("–ù–µ—Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–∞—è –∫–Ω–æ–ø–∫–∞. –í–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –º–µ–Ω—é.", reply_markup=main_menu())

# –¢–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –º–∞—Ä—à—Ä—É—Ç–∏–∑–∏—Ä—É—é—Ç—Å—è –ø–æ state
async def text_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip()
    user = update.effective_user.id
    state = context.user_data.get("state")
    logger.info("text_router user=%s state=%s text=%s", user, state, text[:80])

    if not state:
        await update.message.reply_text("–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤ –º–µ–Ω—é.", reply_markup=main_menu())
        return

    # –Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏
    if state == "await_order":
        context.user_data["order_number"] = text
        context.user_data["state"] = "await_address"
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å:")
        return

    # –∞–¥—Ä–µ—Å
    if state == "await_address":
        context.user_data["address"] = text
        context.user_data["state"] = "await_description"
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:")
        return

    # –æ–ø–∏—Å–∞–Ω–∏–µ
    if state == "await_description":
        context.user_data["description"] = text
        context.user_data["state"] = "await_deadline"
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Å—Ä–æ–∫ (–î–î.MM.–ì–ì –ß–ß:–ú–ú):")
        return

    # —Å—Ä–æ–∫ ‚Äî —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–¥–∞—á—É
    if state == "await_deadline":
        ud = context.user_data.copy()
        try:
            c.execute("""INSERT INTO tasks (user_id, type, client, order_number, description, address, deadline, status)
                         VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                      (user,
                       ud.get("type"),
                       ud.get("client"),
                       ud.get("order_number"),
                       ud.get("description"),
                       ud.get("address"),
                       text,
                       "active"))
            conn.commit()
            tid = c.lastrowid
            await update.message.reply_text(f"‚úÖ –ó–∞–¥–∞—á–∞ #{tid} –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ —Ç–µ–∫—É—â–∏–µ!", reply_markup=main_menu())
            context.user_data.clear()
            return
        except Exception as e:
            logger.exception("DB insert failed")
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {e}", reply_markup=main_menu())
            context.user_data.clear()
            return

    # —Ä–µ–∑–µ—Ä–≤: –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–∏—à–µ—Ç "–≥–æ—Ç–æ–≤–æ" —Ç–µ–∫—Å—Ç–æ–º ‚Äî –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∫–∞–∫ –Ω–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏
    if state == "await_avr" and text.lower() in ("–≥–æ—Ç–æ–≤–æ", "–≥–æ—Ç–æ–≤–æ."):
        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º avr list
        tid = context.user_data.get("complete_id")
        if not tid:
            await update.message.reply_text("‚ùå –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: id –∑–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.", reply_markup=main_menu())
            context.user_data.clear()
            return
        avr_files = context.user_data.get("avr_files", [])
        try:
            avr_json = json.dumps(avr_files, ensure_ascii=False)
            c.execute("UPDATE tasks SET avr=? WHERE id=?", (avr_json, tid))
            conn.commit()
            context.user_data["state"] = "await_solution"
            await update.message.reply_text("‚úÖ –§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã. –¢–µ–ø–µ—Ä—å –æ–ø–∏—à–∏—Ç–µ —Ä–µ—à–µ–Ω–∏–µ (–∫–æ—Ä–æ—Ç–∫–æ):")
        except Exception:
            logger.exception("Failed to save avr via text '–≥–æ—Ç–æ–≤–æ'")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–æ–≤.", reply_markup=main_menu())
            context.user_data.clear()
        return

    # —Ç–µ–∫—Å—Ç —Ä–µ—à–µ–Ω–∏—è
    if state == "await_solution":
        tid = context.user_data.get("complete_id")
        if not tid:
            await update.message.reply_text("‚ùå –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: id –∑–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.", reply_markup=main_menu())
            context.user_data.clear()
            return
        try:
            c.execute("UPDATE tasks SET solution=?, status=? WHERE id=?", (text, "done", tid))
            conn.commit()
            await update.message.reply_text(f"‚úÖ –ó–∞–¥–∞—á–∞ #{tid} –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∏ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é!", reply_markup=main_menu())
            context.user_data.clear()
            return
        except Exception:
            logger.exception("Failed to save solution")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ä–µ—à–µ–Ω–∏—è.", reply_markup=main_menu())
            context.user_data.clear()
            return

    # fallback
    await update.message.reply_text("–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π –≤–≤–æ–¥. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤ –º–µ–Ω—é.", reply_markup=main_menu())

# –î–æ–∫—É–º–µ–Ω—Ç—ã –∏ —Ñ–æ—Ç–æ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ state == await_avr
async def file_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    state = context.user_data.get("state")
    user = update.effective_user.id
    logger.info("file_router user=%s state=%s", user, state)

    if state != "await_avr":
        await update.message.reply_text("–Ø —Å–µ–π—á–∞—Å –Ω–µ –æ–∂–∏–¥–∞—é —Ñ–∞–π–ª—ã. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤ –º–µ–Ω—é.", reply_markup=main_menu())
        return

    tid = context.user_data.get("complete_id")
    if not tid:
        await update.message.reply_text("‚ùå –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: id –∑–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.", reply_markup=main_menu())
        context.user_data.clear()
        return

    allowed_ext = (".pdf", ".jpg", ".jpeg", ".png", ".heic")

    # –¥–æ–∫—É–º–µ–Ω—Ç (pdf, heic, jpg as document)
    if update.message.document:
        doc = update.message.document
        orig_name = doc.file_name or f"file_{tid}"
        _, ext = os.path.splitext(orig_name)
        if ext.lower() not in allowed_ext:
            await update.message.reply_text("‚ö†Ô∏è –†–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ PDF/JPG/PNG/HEIC.")
            return
        tgfile = await doc.get_file()
        safe_name = uniq_name(orig_name)
        path = os.path.join(FILES_DIR, safe_name)
        await tgfile.download_to_drive(path)
        context.user_data.setdefault("avr_files", []).append({"path": path, "name": orig_name})
        await update.message.reply_text(f"‚úÖ –§–∞–π–ª {orig_name} —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –ù–∞–∂–º–∏—Ç–µ ¬´–ì–æ—Ç–æ–≤–æ¬ª, –∫–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ.")
        return

    # —Ñ–æ—Ç–æ (telegram photo sizes)
    if update.message.photo:
        photo = update.message.photo[-1]  # –ª—É—á—à–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ
        tgfile = await photo.get_file()
        orig_name = f"photo_{photo.file_unique_id}.jpg"
        safe_name = uniq_name(orig_name)
        path = os.path.join(FILES_DIR, safe_name)
        await tgfile.download_to_drive(path)
        context.user_data.setdefault("avr_files", []).append({"path": path, "name": orig_name})
        await update.message.reply_text("‚úÖ –§–æ—Ç–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ. –ù–∞–∂–º–∏—Ç–µ ¬´–ì–æ—Ç–æ–≤–æ¬ª, –∫–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ.")
        return

    # –∏–Ω–∞—á–µ
    await update.message.reply_text("–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø —Ñ–∞–π–ª–∞. –†–∞–∑—Ä–µ—à–µ–Ω—ã PDF/JPG/PNG/HEIC –∏ —Ñ–æ—Ç–æ.")

# –û—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É –∑–∞–¥–∞—á–∏
async def open_task_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    tid = int(query.data.split("_")[1])
    logger.info("open_task %s by %s", tid, query.from_user.id)
    c.execute("SELECT * FROM tasks WHERE id=?", (tid,))
    row = c.fetchone()
    if not row:
        await query.message.reply_text("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", reply_markup=main_menu())
        return
    _, user_id, ttype, client, order, desc, addr, deadline, avr_json, sol, status = row

    lines = []
    lines.append(f"üÜî <b>–ó–∞–¥–∞—á–∞ #{tid}</b>")
    lines.append(f"üìå <b>–¢–∏–ø:</b> {'üöó –í—ã–µ–∑–¥–Ω–∞—è' if ttype == 'field' else 'üìù –û–±—â–∞—è'}")
    if client: lines.append(f"üè¢ <b>–ö–ª–∏–µ–Ω—Ç:</b> {client}")
    if order: lines.append(f"‚Ññ <b>–ó–∞—è–≤–∫–∏:</b> {order}")
    if desc: lines.append(f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> {desc}")
    if addr:
        lines.append(f"üìç <b>–ê–¥—Ä–µ—Å:</b> {addr}")
        lines.append(f"üîó <a href='https://yandex.ru/maps/?text={addr}'>–û—Ç–∫—Ä—ã—Ç—å –≤ –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç–∞—Ö</a>")
    lines.append(f"‚è∞ <b>–°—Ä–æ–∫:</b> {deadline}")
    lines.append(f"üìä <b>–°—Ç–∞—Ç—É—Å:</b> {'‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞' if status == 'done' else 'üïí –ê–∫—Ç–∏–≤–Ω–∞'}")
    if status == "done" and sol:
        lines.append(f"üìù <b>–†–µ—à–µ–Ω–∏–µ:</b> {sol}")

    kb = []
    if status != "done":
        kb.append([InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data=f"complete_{tid}")])
    kb.append([InlineKeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"delete_{tid}")])
    kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])

    await query.message.reply_text("\n".join(lines), parse_mode="HTML", reply_markup=InlineKeyboardMarkup(kb), disable_web_page_preview=True)

    # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º avr —Ñ–∞–π–ª—ã, –µ—Å–ª–∏ –µ—Å—Ç—å
    if avr_json:
        try:
            avr_list = json.loads(avr_json)
            for f in avr_list:
                path = f.get("path")
                name = f.get("name")
                if path and os.path.isfile(path):
                    try:
                        # InputFile –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —É–∫–∞–∑–∞–Ω–∏–µ –∏–º–µ–Ω–∏
                        await query.message.reply_document(document=InputFile(path, filename=name), caption=f"üìé {name}")
                    except Exception:
                        # –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
                        try:
                            await query.message.reply_document(open(path, "rb"), caption=f"üìé {name}")
                        except Exception:
                            logger.exception("Failed to send file %s", path)
                else:
                    logger.warning("File not found: %s", path)
        except Exception:
            logger.exception("Failed to parse avr_json")

# –ù–∞—á–∞–ª–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è ‚Äî –ø—Ä–æ—Å–∏–º —Ñ–∞–π–ª—ã –∏ –¥–∞—ë–º –∫–Ω–æ–ø–∫—É "–ì–æ—Ç–æ–≤–æ"
async def start_complete_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    tid = int(query.data.split("_")[1])
    context.user_data.clear()
    context.user_data["complete_id"] = tid
    context.user_data["state"] = "await_avr"
    context.user_data["avr_files"] = []
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="avr_done")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data=f"open_{tid}")]
    ])
    await query.message.reply_text(
        "üìé –ü—Ä–∏–∫—Ä–µ–ø–∏—Ç–µ —Ñ–∞–π–ª—ã –ê–í–† (pdf/jpg/png/heic) –∏–ª–∏ —Ñ–æ—Ç–æ.\n–ú–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–¥—Ä—è–¥.\n–ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ ‚Äî –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É ¬´–ì–æ—Ç–æ–≤–æ¬ª.",
        reply_markup=kb
    )

# –£–¥–∞–ª–µ–Ω–∏–µ
async def delete_task_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    tid = int(query.data.split("_")[1])
    await query.message.reply_text(f"‚ö†Ô∏è –£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É #{tid}?", reply_markup=confirm_delete_kb(tid))

async def confirm_delete_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    try:
        tid = int(query.data.split("_")[2])
        c.execute("DELETE FROM tasks WHERE id=?", (tid,))
        conn.commit()
        await query.message.reply_text(f"üóë –ó–∞–¥–∞—á–∞ #{tid} —É–¥–∞–ª–µ–Ω–∞.", reply_markup=main_menu())
    except Exception:
        logger.exception("Failed to delete task")
        await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏.", reply_markup=main_menu())

# –ö–æ–º–∞–Ω–¥–∞ –æ—Ç–∫—Ä—ã—Ç—å –∑–∞–¥–∞—á—É –ø–æ id: /task <id>
async def cmd_task_by_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    args = context.args
    if not args:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /task <id>")
        return
    try:
        tid = int(args[0])
    except ValueError:
        await update.message.reply_text("ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
        return
    # —ç–º—É–ª–∏—Ä—É–µ–º open
    class Dummy:
        def __init__(self, chat_id):
            self.chat_id = chat_id
        async def reply_text(self, *a, **k):
            return await update.message.reply_text(*a, **k)
    # –∏—Å–ø–æ–ª—å–∑—É–µ–º open logic by querying DB and sending same messages
    c.execute("SELECT * FROM tasks WHERE id=?", (tid,))
    row = c.fetchone()
    if not row:
        await update.message.reply_text("–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", reply_markup=main_menu())
        return
    _, user_id, ttype, client, order, desc, addr, deadline, avr_json, sol, status = row
    lines = []
    lines.append(f"üÜî <b>–ó–∞–¥–∞—á–∞ #{tid}</b>")
    lines.append(f"üìå <b>–¢–∏–ø:</b> {'üöó –í—ã–µ–∑–¥–Ω–∞—è' if ttype == 'field' else 'üìù –û–±—â–∞—è'}")
    if client: lines.append(f"üè¢ <b>–ö–ª–∏–µ–Ω—Ç:</b> {client}")
    if order: lines.append(f"‚Ññ <b>–ó–∞—è–≤–∫–∏:</b> {order}")
    if desc: lines.append(f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> {desc}")
    if addr:
        lines.append(f"üìç <b>–ê–¥—Ä–µ—Å:</b> {addr}")
        lines.append(f"üîó <a href='https://yandex.ru/maps/?text={addr}'>–û—Ç–∫—Ä—ã—Ç—å –≤ –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç–∞—Ö</a>")
    lines.append(f"‚è∞ <b>–°—Ä–æ–∫:</b> {deadline}")
    lines.append(f"üìä <b>–°—Ç–∞—Ç—É—Å:</b> {'‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞' if status == 'done' else 'üïí –ê–∫—Ç–∏–≤–Ω–∞'}")
    if status == "done" and sol:
        lines.append(f"üìù <b>–†–µ—à–µ–Ω–∏–µ:</b> {sol}")

    await update.message.reply_text("\n".join(lines), parse_mode="HTML", reply_markup=main_menu())
    if avr_json:
        try:
            avr_list = json.loads(avr_json)
            for f in avr_list:
                path = f.get("path"); name = f.get("name")
                if path and os.path.isfile(path):
                    try:
                        await update.message.reply_document(document=InputFile(path, filename=name), caption=f"üìé {name}")
                    except Exception:
                        try:
                            await update.message.reply_document(open(path,"rb"), caption=f"üìé {name}")
                        except Exception:
                            logger.exception("Failed to send file %s", path)
        except Exception:
            logger.exception("Failed to send avr files for /task")

# --------------- –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∏ –∑–∞–ø—É—Å–∫–∞–µ–º ---------------

def main():
    if TOKEN == "8288052246:AAH2HkB5MVqBA8M6gINmLCap0wZ7Fyn8jKY" or not TOKEN:
        raise SystemExit("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–ø–∏—à–∏—Ç–µ —Ç–æ–∫–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π TOKEN –≤ –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞.")

    app = Application.builder().token(TOKEN).build()

    # –∫–æ–º–∞–Ω–¥—ã
    app.add_handler(CommandHandler("start", start_cmd))
    app.add_handler(CommandHandler("task", cmd_task_by_id))

    # –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é (new/current/history/back)
    app.add_handler(CallbackQueryHandler(main_buttons_callback, pattern="^(new|current|history|back_main)$"))

    # callback router (–≤—Å–µ dialog-related –∏ avr_done)
    # pattern –≤–∫–ª—é—á–∞–µ—Ç: —Ç–∏–ø—ã, –∫–ª–∏–µ–Ω—Ç—ã, open_x, complete_x, delete_x, confirm_delete_x, avr_done
    pattern = r"^(general|field|–ú–∞–∫—Å–∞–≤–∏—Ç|–ì–∞–∑–ø—Ä–æ–º–Ω–µ—Ñ—Ç—å|–ì–ª–æ—Ä–∏—è –î–∂–∏–Ω—Å|–ü–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫|–¢–µ–±–æ–π–ª|–¢–∞—Ç–Ω–µ—Ñ—Ç—å|open_\d+|complete_\d+|delete_\d+|confirm_delete_\d+|avr_done|back_main)$"
    app.add_handler(CallbackQueryHandler(callback_router, pattern=pattern))

    # —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, text_router))

    # –¥–æ–∫—É–º–µ–Ω—Ç—ã –∏ —Ñ–æ—Ç–æ
    app.add_handler(MessageHandler(filters.Document.ALL | filters.PHOTO, file_router))

    logger.info("Bot starting...")
    app.run_polling(allowed_updates=["message", "callback_query", "document", "photo"])

if __name__ == "__main__":
    main()
