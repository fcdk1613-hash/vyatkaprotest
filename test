#!/usr/bin/env python3
# coding: utf-8

import os
import re
import json
import logging
import sqlite3
from uuid import uuid4
from datetime import datetime
from urllib.parse import quote_plus

from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    InputFile,
)
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ConversationHandler,
    ContextTypes,
    filters,
)

# ----------------- CONFIG -----------------
TOKEN = "8288052246:AAH2HkB5MVqBA8M6gINmLCap0wZ7Fyn8jKY"  # <-- –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ç–æ–∫–µ–Ω –æ—Ç BotFather

FILES_DIR = "avr_files"
os.makedirs(FILES_DIR, exist_ok=True)

ALLOWED_EXT = (".pdf", ".jpg", ".jpeg", ".png", ".heic")

# ----------------- LOGGING -----------------
logging.basicConfig(
    format="%(asctime)s %(levelname)s %(name)s: %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ----------------- DB -----------------
DB_PATH = "tasks.db"
conn = sqlite3.connect(DB_PATH, check_same_thread=False)
c = conn.cursor()
c.execute("""
CREATE TABLE IF NOT EXISTS tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    type TEXT,             -- general | field
    client TEXT,
    order_number TEXT,
    description TEXT,
    address TEXT,
    deadline TEXT,         -- as entered: DD.MM.YY HH:MM or DD.MM.YYYY HH:MM
    status TEXT,           -- active | done
    avr TEXT,              -- JSON list [{"path": "...", "name":"..."}]
    solution TEXT
)
""")
conn.commit()

# ----------------- STATES -----------------
# we'll use ConversationHandler states for main flows and manual context.user_data states inside them
(
    S_MAIN,                 # main menu
    S_NEW_TYPE,             # choose new type
    S_GENERAL_DESC,         # general: description
    S_FIELD_ORDER,          # field: order number
    S_FIELD_CLIENT,         # choose client
    S_FIELD_ADDRESS,        # address
    S_FIELD_DESC,           # description
    S_FIELD_DEADLINE,       # deadline
    S_COMPLETE_AVR,         # uploading multiple AVR files
    S_COMPLETE_SOLUTION,    # final solution text
    S_HISTORY_MENU,         # history main options (date/search)
    S_HISTORY_YEAR,         # choose year
    S_HISTORY_MONTH,        # choose month
    S_HISTORY_DAY,          # choose day
    S_HISTORY_SEARCH_INPUT  # search input
) = range(15)

# clients list
CLIENTS = ["–ú–∞–∫—Å–∞–≤–∏—Ç", "–ì–∞–∑–ø—Ä–æ–º–Ω–µ—Ñ—Ç—å", "–ì–ª–æ—Ä–∏—è –î–∂–∏–Ω—Å", "–ü–µ—Ä–µ–∫—Ä–µ—Å—Ç–æ–∫", "–¢–µ–±–æ–π–ª", "–¢–∞—Ç–Ω–µ—Ñ—Ç—å"]

# ----------------- UI helpers -----------------
def kb_main_menu():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ûï –ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞", callback_data="new")],
        [InlineKeyboardButton("üìå –¢–µ–∫—É—â–∏–µ", callback_data="current"),
         InlineKeyboardButton("üìú –ò—Å—Ç–æ—Ä–∏—è", callback_data="history")],
        [InlineKeyboardButton("‚Ñπ /task <id>", callback_data="help_task")]
    ])

def kb_type_menu():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üìù –û–±—â–∞—è", callback_data="type_general"),
         InlineKeyboardButton("üöó –í—ã–µ–∑–¥–Ω–∞—è", callback_data="type_field")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")]
    ])

def kb_clients():
    rows = []
    for i in range(0, len(CLIENTS), 2):
        row = []
        row.append(InlineKeyboardButton(CLIENTS[i], callback_data=f"client_{CLIENTS[i]}"))
        if i+1 < len(CLIENTS):
            row.append(InlineKeyboardButton(CLIENTS[i+1], callback_data=f"client_{CLIENTS[i+1]}"))
        rows.append(row)
    rows.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
    return InlineKeyboardMarkup(rows)

def kb_task_back():
    return InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")]])

def kb_done_avr(task_id: int):
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data=f"avr_done_{task_id}")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data=f"open_{task_id}")]
    ])

def kb_history_menu():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üìÖ –§–∏–ª—å—Ç—Ä –ø–æ –¥–∞—Ç–µ", callback_data="hist_date")],
        [InlineKeyboardButton("üîç –ü–æ–∏—Å–∫", callback_data="hist_search")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")]
    ])

# ----------------- Utils -----------------
def uniq_filename(name: str) -> str:
    safe = name.replace("/", "_").replace("\\", "_")
    return f"{uuid4().hex[:8]}_{safe}"

def parse_deadline_to_dt(text: str) -> datetime | None:
    # Accept DD.MM.YY HH:MM or DD.MM.YYYY HH:MM
    if not text:
        return None
    text = text.strip()
    # try patterns
    for fmt in ("%d.%m.%y %H:%M", "%d.%m.%Y %H:%M"):
        try:
            return datetime.strptime(text, fmt)
        except Exception:
            continue
    return None

def format_date_ymd(dt: datetime) -> tuple:
    # returns (year, month, day)
    return dt.year, dt.month, dt.day

def rows_to_task_buttons(rows):
    kb = []
    for row in rows:
        tid = row[0]
        ttype = row[2]  # type is at index 2? careful: SELECT columns vary; caller should use full row with known order
        # This helper is not used; callers build labels explicitly.

# ----------------- Handlers -----------------
# /start
async def start_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    await update.message.reply_text("üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏.", reply_markup=kb_main_menu())
    return S_MAIN

# main menu callback router
async def main_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data

    if data == "new":
        context.user_data.clear()
        await query.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∑–∞–¥–∞—á–∏:", reply_markup=kb_type_menu())
        return S_NEW_TYPE

    if data == "current":
        # list active tasks
        c.execute("SELECT id, type, client, address, description, deadline FROM tasks WHERE status='active' ORDER BY id DESC")
        rows = c.fetchall()
        if not rows:
            await query.message.reply_text("üì≠ –ù–µ—Ç —Ç–µ–∫—É—â–∏—Ö –∑–∞–¥–∞—á.", reply_markup=kb_main_menu())
            return S_MAIN
        kb = []
        for r in rows:
            tid, ttype, client, addr, desc, dl = r
            if ttype == "field":
                label = f"#{tid} {client} | {addr}"
            else:
                label = f"#{tid} {(desc or '')[:30]}"
            kb.append([InlineKeyboardButton(label, callback_data=f"open_{tid}")])
        kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
        await query.message.reply_text("üìå –¢–µ–∫—É—â–∏–µ –∑–∞–¥–∞—á–∏:", reply_markup=InlineKeyboardMarkup(kb))
        return S_MAIN

    if data == "history":
        # go to history menu
        await query.message.edit_text("üìÇ –ò—Å—Ç–æ—Ä–∏—è ‚Äî –≤—ã–±–æ—Ä:", reply_markup=kb_history_menu())
        return S_HISTORY_MENU

    if data == "help_task":
        await query.message.reply_text("‚Ñπ –ö–æ–º–∞–Ω–¥–∞: /task <id> ‚Äî –æ—Ç–∫—Ä—ã—Ç—å –∑–∞–¥–∞—á—É –ø–æ ID.", reply_markup=kb_main_menu())
        return S_MAIN

    if data == "back_main":
        context.user_data.clear()
        await query.message.edit_text("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=kb_main_menu())
        return S_MAIN

    # fallback
    await query.message.reply_text("–ù–µ—Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ.", reply_markup=kb_main_menu())
    return S_MAIN

# choose type handler
async def choose_type_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    if data == "type_general":
        context.user_data.clear()
        context.user_data["creating_type"] = "general"
        await query.message.edit_text("‚úè –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –æ–±—â–µ–π –∑–∞–¥–∞—á–∏:")
        return S_GENERAL_DESC
    if data == "type_field":
        context.user_data.clear()
        context.user_data["creating_type"] = "field"
        await query.message.edit_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏:")
        return S_FIELD_ORDER
    if data == "back_main":
        context.user_data.clear()
        await query.message.edit_text("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=kb_main_menu())
        return S_MAIN
    # else unknown
    await query.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä.")
    return S_NEW_TYPE

# general description receive
async def general_desc_receive(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    if not text:
        await update.message.reply_text("–û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç:")
        return S_GENERAL_DESC
    c.execute("INSERT INTO tasks (user_id, type, description, status) VALUES (?, ?, ?, ?)",
              (update.effective_user.id, "general", text, "active"))
    conn.commit()
    tid = c.lastrowid
    await update.message.reply_text(f"‚úÖ –û–±—â–∞—è –∑–∞–¥–∞—á–∞ #{tid} –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ —Ç–µ–∫—É—â–∏–µ.", reply_markup=kb_main_menu())
    context.user_data.clear()
    return S_MAIN

# field order receive
async def field_order_receive(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    if not text:
        await update.message.reply_text("–ù–æ–º–µ—Ä –∑–∞—è–≤–∫–∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä:")
        return S_FIELD_ORDER
    context.user_data["order_number"] = text
    # show clients
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∏–µ–Ω—Ç–∞:", reply_markup=kb_clients())
    return S_FIELD_CLIENT

# field client callback
async def field_client_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    if not data.startswith("client_"):
        await query.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–∞.")
        return S_FIELD_CLIENT
    client = data.split("_", 1)[1]
    context.user_data["client"] = client
    await query.message.edit_text(f"–ö–ª–∏–µ–Ω—Ç: {client}\n–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π):")
    return S_FIELD_ADDRESS

# address receive
async def field_address_receive(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    if not text:
        await update.message.reply_text("–ê–¥—Ä–µ—Å –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å:")
        return S_FIELD_ADDRESS
    context.user_data["address"] = text
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:")
    return S_FIELD_DESC

# description receive
async def field_desc_receive(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    if not text:
        await update.message.reply_text("–û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ:")
        return S_FIELD_DESC
    context.user_data["description"] = text
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Å—Ä–æ–∫ (–î–î.MM.–ìG HH:MM). –ü—Ä–∏–º–µ—Ä: 28.09.25 15:30")
    return S_FIELD_DEADLINE

# deadline receive and save field task
async def field_deadline_receive(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    dt = parse_deadline_to_dt(text)
    if not dt:
        await update.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –û–∂–∏–¥–∞–µ—Ç—Å—è –î–î.MM.YY HH:MM –∏–ª–∏ –î–î.MM.YYYY HH:MM. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:")
        return S_FIELD_DEADLINE
    # save to DB
    user_id = update.effective_user.id
    c.execute("""INSERT INTO tasks (user_id, type, client, order_number, description, address, deadline, status)
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
              (user_id, "field", context.user_data.get("client"), context.user_data.get("order_number"),
               context.user_data.get("description"), context.user_data.get("address"),
               text, "active"))
    conn.commit()
    tid = c.lastrowid
    await update.message.reply_text(f"‚úÖ –í—ã–µ–∑–¥–Ω–∞—è –∑–∞–¥–∞—á–∞ #{tid} —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.", reply_markup=kb_main_menu())
    context.user_data.clear()
    return S_MAIN

# open task detail (from current or history)
async def open_task_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data  # open_<id>
    try:
        tid = int(data.split("_", 1)[1])
    except Exception:
        await query.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π ID –∑–∞–¥–∞—á–∏.")
        return S_MAIN
    c.execute("SELECT * FROM tasks WHERE id=?", (tid,))
    row = c.fetchone()
    if not row:
        await query.message.reply_text("–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", reply_markup=kb_main_menu())
        return S_MAIN
    # row indices: id, user_id, type, client, order_number, description, address, deadline, status, avr, solution
    _, user_id, ttype, client, order_number, description, address, deadline, status, avr_json, solution = row
    lines = []
    lines.append(f"üÜî <b>–ó–∞–¥–∞—á–∞ #{tid}</b>")
    lines.append(f"üìå <b>–¢–∏–ø:</b> {'üöó –í—ã–µ–∑–¥–Ω–∞—è' if ttype == 'field' else 'üìù –û–±—â–∞—è'}")
    if client: lines.append(f"üè¢ <b>–ö–ª–∏–µ–Ω—Ç:</b> {client}")
    if order_number: lines.append(f"‚Ññ <b>–ó–∞—è–≤–∫–∏:</b> {order_number}")
    if description: lines.append(f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> {description}")
    if address:
        lines.append(f"üìç <b>–ê–¥—Ä–µ—Å:</b> {address}")
    lines.append(f"‚è∞ <b>–°—Ä–æ–∫:</b> {deadline}")
    lines.append(f"üìä <b>–°—Ç–∞—Ç—É—Å:</b> {'‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞' if status == 'done' else 'üïí –ê–∫—Ç–∏–≤–Ω–∞'}")
    if status == "done" and solution:
        lines.append(f"üõ† <b>–†–µ—à–µ–Ω–∏–µ:</b> {solution}")

    # build keyboard: if field ‚Äî map button; if active ‚Äî close button.
    kb = []
    if ttype == "field" and address:
        map_url = f"https://yandex.ru/maps/?text={quote_plus(address)}"
        kb.append([InlineKeyboardButton("üìç –û—Ç–∫—Ä—ã—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ", url=map_url)])
    if status != "done":
        kb.append([InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data=f"complete_{tid}")])
    kb.append([InlineKeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"delete_{tid}")])
    kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])

    await query.message.reply_text("\n".join(lines), parse_mode="HTML", reply_markup=InlineKeyboardMarkup(kb), disable_web_page_preview=True)

    # if done and avr files exist ‚Äî send them
    if avr_json:
        try:
            avr_list = json.loads(avr_json)
            for f in avr_list:
                path = f.get("path"); name = f.get("name")
                if path and os.path.isfile(path):
                    try:
                        await query.message.reply_document(document=InputFile(path, filename=name), caption=f"üìé {name}")
                    except Exception:
                        try:
                            await query.message.reply_document(open(path, "rb"), caption=f"üìé {name}")
                        except Exception:
                            logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª %s", path)
                else:
                    logger.warning("–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: %s", path)
        except Exception:
            logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ avr JSON")
    return S_MAIN

# delete flow
async def delete_task_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data  # delete_<id>
    try:
        tid = int(data.split("_", 1)[1])
    except Exception:
        await query.message.reply_text("–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π ID")
        return S_MAIN
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ùå –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ", callback_data=f"confirm_delete_{tid}")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data=f"open_{tid}")]
    ])
    await query.message.reply_text(f"‚ö† –£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É #{tid}?", reply_markup=kb)
    return S_MAIN

async def confirm_delete_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data  # confirm_delete_<id>
    try:
        tid = int(data.split("_", 2)[2])
    except Exception:
        await query.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç")
        return S_MAIN
    try:
        c.execute("DELETE FROM tasks WHERE id=?", (tid,))
        conn.commit()
        await query.message.reply_text(f"üóë –ó–∞–¥–∞—á–∞ #{tid} —É–¥–∞–ª–µ–Ω–∞.", reply_markup=kb_main_menu())
    except Exception:
        logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏")
        await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏.")
    return S_MAIN

# complete (start uploading multiple AVR files)
async def complete_start_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data  # complete_<id> or open_comp...
    try:
        tid = int(data.split("_", 1)[1])
    except Exception:
        await query.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π ID")
        return S_MAIN
    # prepare context for multiple files
    context.user_data["complete_id"] = tid
    context.user_data["avr_files"] = []
    context.user_data["state_manual"] = "await_avr"
    await query.message.reply_text(
        "üìé –ü—Ä–∏–∫—Ä–µ–ø–∏—Ç–µ —Ñ–∞–π–ª—ã –ê–í–† (pdf/jpg/png/heic) ‚Äî –º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–¥—Ä—è–¥.\n"
        "–ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç–µ ‚Äî –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É ¬´–ì–æ—Ç–æ–≤–æ¬ª.",
        reply_markup=kb_done_avr(tid)
    )
    return S_COMPLETE_AVR

# handler when user uploads documents/photos during completion
async def avr_file_receive(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # ensure we're in the flow
    state = context.user_data.get("state_manual")
    if state != "await_avr":
        await update.message.reply_text("–Ø —Å–µ–π—á–∞—Å –Ω–µ –æ–∂–∏–¥–∞—é —Ñ–∞–π–ª—ã. –ù–∞–∂–º–∏—Ç–µ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=kb_main_menu())
        return S_MAIN

    tid = context.user_data.get("complete_id")
    if not tid:
        await update.message.reply_text("–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: id –∑–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.", reply_markup=kb_main_menu())
        context.user_data.clear()
        return S_MAIN

    # document
    if update.message.document:
        doc = update.message.document
        orig_name = doc.file_name or f"file_{tid}"
        _, ext = os.path.splitext(orig_name)
        if ext.lower() not in ALLOWED_EXT:
            await update.message.reply_text("‚ö† –†–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ PDF/JPG/PNG/HEIC.")
            return S_COMPLETE_AVR
        tgfile = await doc.get_file()
        saved = uniq_filename(orig_name)
        path = os.path.join(FILES_DIR, saved)
        await tgfile.download_to_drive(path)
        context.user_data.setdefault("avr_files", []).append({"path": path, "name": orig_name})
        await update.message.reply_text(f"‚úÖ –§–∞–π–ª {orig_name} —Å–æ—Ö—Ä–∞–Ω—ë–Ω. –î–æ–±–∞–≤—å—Ç–µ –µ—â—ë –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–ì–æ—Ç–æ–≤–æ¬ª.", reply_markup=kb_done_avr(tid))
        return S_COMPLETE_AVR

    # photo
    if update.message.photo:
        photo = update.message.photo[-1]
        tgfile = await photo.get_file()
        orig_name = f"photo_{photo.file_unique_id}.jpg"
        saved = uniq_filename(orig_name)
        path = os.path.join(FILES_DIR, saved)
        await tgfile.download_to_drive(path)
        context.user_data.setdefault("avr_files", []).append({"path": path, "name": orig_name})
        await update.message.reply_text("‚úÖ –§–æ—Ç–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ. –î–æ–±–∞–≤—å—Ç–µ –µ—â—ë –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–ì–æ—Ç–æ–≤–æ¬ª.", reply_markup=kb_done_avr(tid))
        return S_COMPLETE_AVR

    await update.message.reply_text("–¢–∏–ø —Ñ–∞–π–ª–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –ü—Ä–∏—à–ª–∏—Ç–µ pdf/jpg/png/heic –∏–ª–∏ —Ñ–æ—Ç–æ.")
    return S_COMPLETE_AVR

# button "Done" callback while uploading AVR
async def avr_done_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    # callback_data = avr_done_<tid>
    parts = query.data.split("_")
    if len(parts) >= 3:
        try:
            tid = int(parts[2])
        except Exception:
            tid = context.user_data.get("complete_id")
    else:
        tid = context.user_data.get("complete_id")
    if not tid:
        await query.message.reply_text("–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: id –∑–∞–¥–∞—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        context.user_data.clear()
        return S_MAIN
    avr_files = context.user_data.get("avr_files", [])
    try:
        c.execute("UPDATE tasks SET avr=? WHERE id=?", (json.dumps(avr_files, ensure_ascii=False), tid))
        conn.commit()
    except Exception:
        logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å AVR –≤ –ë–î")
        await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–æ–≤.")
        context.user_data.clear()
        return S_MAIN
    context.user_data["state_manual"] = "await_solution"
    context.user_data["complete_id"] = tid
    await query.message.reply_text("‚úè –ù–∞–ø–∏—à–∏—Ç–µ –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è:")
    return S_COMPLETE_SOLUTION

# solution receive and finish
async def solution_receive(update: Update, context: ContextTypes.DEFAULT_TYPE):
    state = context.user_data.get("state_manual")
    if state != "await_solution":
        await update.message.reply_text("–Ø –Ω–µ –æ–∂–∏–¥–∞–ª —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ. –í–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –º–µ–Ω—é.", reply_markup=kb_main_menu())
        return S_MAIN
    tid = context.user_data.get("complete_id")
    if not tid:
        await update.message.reply_text("–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: id –Ω–µ –Ω–∞–π–¥–µ–Ω.", reply_markup=kb_main_menu())
        context.user_data.clear()
        return S_MAIN
    sol = update.message.text.strip()
    try:
        c.execute("UPDATE tasks SET solution=?, status=? WHERE id=?", (sol, "done", tid))
        conn.commit()
        await update.message.reply_text(f"‚úÖ –ó–∞–¥–∞—á–∞ #{tid} –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∏ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é.", reply_markup=kb_main_menu())
    except Exception:
        logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ä–µ—à–µ–Ω–∏—è")
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏.", reply_markup=kb_main_menu())
    context.user_data.clear()
    return S_MAIN

# HISTORY flows: menu -> date filter or search
async def history_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    if data == "hist_date":
        # build list of years from done tasks deadlines
        c.execute("SELECT deadline FROM tasks WHERE status='done' AND deadline IS NOT NULL")
        rows = c.fetchall()
        years = set()
        for (dl,) in rows:
            dt = parse_deadline_to_dt(dl)
            if dt:
                years.add(dt.year)
        if not years:
            await query.message.reply_text("–ù–µ—Ç –¥–∞—Ç –≤ –∏—Å—Ç–æ—Ä–∏–∏.", reply_markup=kb_main_menu())
            return S_MAIN
        years = sorted(list(years), reverse=True)
        kb = [[InlineKeyboardButton(str(y), callback_data=f"hist_year_{y}")] for y in years]
        kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="history_back")])
        await query.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –≥–æ–¥:", reply_markup=InlineKeyboardMarkup(kb))
        return S_HISTORY_YEAR

    if data == "hist_search":
        await query.message.reply_text("üîç –í–≤–µ–¥–∏—Ç–µ —Å—Ç—Ä–æ–∫—É –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –Ω–æ–º–µ—Ä—É –∑–∞—è–≤–∫–∏, –∫–ª–∏–µ–Ω—Ç—É –∏–ª–∏ –∞–¥—Ä–µ—Å—É:")
        context.user_data["history_search"] = ""
        return S_HISTORY_SEARCH_INPUT

    if data == "back_main":
        await query.message.edit_message_text("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=kb_main_menu())
        return S_MAIN

    if data == "back_main" or data == "history_back":
        await query.message.edit_text("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=kb_main_menu())
        return S_MAIN

    # fallback
    await query.message.reply_text("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ–ø—Ü–∏—è –∏—Å—Ç–æ—Ä–∏–∏.", reply_markup=kb_main_menu())
    return S_MAIN

# choose year -> show months
async def history_year_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data  # hist_year_<YYYY>
    parts = data.split("_")
    if len(parts) != 3:
        await query.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≥–æ–¥–∞.")
        return S_HISTORY_YEAR
    year = int(parts[2])
    # get months available for this year
    c.execute("SELECT deadline FROM tasks WHERE status='done' AND deadline IS NOT NULL")
    rows = c.fetchall()
    months = set()
    for (dl,) in rows:
        dt = parse_deadline_to_dt(dl)
        if dt and dt.year == year:
            months.add(dt.month)
    if not months:
        await query.message.reply_text("–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –∑–∞ —ç—Ç–æ—Ç –≥–æ–¥.", reply_markup=kb_main_menu())
        return S_MAIN
    months = sorted(list(months))
    kb = []
    for m in months:
        kb.append([InlineKeyboardButton(f"{m:02d}", callback_data=f"hist_month_{year}_{m}")])
    kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="history_back")])
    await query.message.reply_text(f"–ì–æ–¥: {year}. –í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Å—è—Ü:", reply_markup=InlineKeyboardMarkup(kb))
    return S_HISTORY_MONTH

# choose month -> show days
async def history_month_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data  # hist_month_YYYY_M
    parts = data.split("_")
    if len(parts) != 4:
        await query.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –º–µ—Å—è—Ü–∞.")
        return S_HISTORY_MONTH
    year = int(parts[2]); month = int(parts[3])
    c.execute("SELECT id, deadline FROM tasks WHERE status='done' AND deadline IS NOT NULL")
    rows = c.fetchall()
    days = {}
    for tid, dl in rows:
        dt = parse_deadline_to_dt(dl)
        if dt and dt.year == year and dt.month == month:
            days.setdefault(dt.day, []).append(tid)
    if not days:
        await query.message.reply_text("–ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –∑–∞ —ç—Ç–æ—Ç –º–µ—Å—è—Ü.", reply_markup=kb_main_menu())
        return S_MAIN
    kb = []
    for d in sorted(days.keys()):
        kb.append([InlineKeyboardButton(f"{d:02d}", callback_data=f"hist_day_{year}_{month}_{d}")])
    kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="history_back")])
    await query.message.reply_text(f"{year}-{month:02d}. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å:", reply_markup=InlineKeyboardMarkup(kb))
    return S_HISTORY_DAY

# choose day -> show list of tasks of that day
async def history_day_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data  # hist_day_YYYY_M_D
    parts = data.split("_")
    if len(parts) != 5:
        await query.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–Ω—è.")
        return S_HISTORY_DAY
    year = int(parts[2]); month = int(parts[3]); day = int(parts[4])
    c.execute("SELECT id, type, client, address, description, deadline FROM tasks WHERE status='done' AND deadline IS NOT NULL")
    rows = c.fetchall()
    pick = []
    for r in rows:
        tid, ttype, client, address, desc, dl = r
        dt = parse_deadline_to_dt(dl)
        if dt and dt.year == year and dt.month == month and dt.day == day:
            if ttype == "field":
                label = f"#{tid} {client} | {address}"
            else:
                label = f"#{tid} { (desc or '')[:30] }"
            pick.append((tid, label))
    if not pick:
        await query.message.reply_text("–ó–∞–ø–∏—Å–µ–π –∑–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –Ω–µ—Ç.", reply_markup=kb_main_menu())
        return S_MAIN
    kb = [[InlineKeyboardButton(label, callback_data=f"open_{tid}")] for tid, label in pick]
    kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="history_back")])
    await query.message.reply_text(f"–ó–∞–¥–∞—á–∏ –∑–∞ {day:02d}.{month:02d}.{year}:", reply_markup=InlineKeyboardMarkup(kb))
    return S_MAIN

# search input handler
async def history_search_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    if not text:
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –ø–æ–∏—Å–∫–æ–≤—É—é —Å—Ç—Ä–æ–∫—É (–Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏, –∫–ª–∏–µ–Ω—Ç –∏–ª–∏ –∞–¥—Ä–µ—Å):")
        return S_HISTORY_SEARCH_INPUT
    q = f"%{text}%"
    c.execute("SELECT id, type, client, address, description FROM tasks WHERE (order_number LIKE ? OR client LIKE ? OR address LIKE ?) AND status='done'", (q, q, q))
    rows = c.fetchall()
    if not rows:
        await update.message.reply_text("–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", reply_markup=kb_main_menu())
        return S_MAIN
    kb = []
    for r in rows:
        tid, ttype, client, address, desc = r
        if ttype == "field":
            label = f"#{tid} {client} | {address}"
        else:
            label = f"#{tid} { (desc or '')[:30] }"
        kb.append([InlineKeyboardButton(label, callback_data=f"open_{tid}")])
    kb.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
    await update.message.reply_text("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞:", reply_markup=InlineKeyboardMarkup(kb))
    return S_MAIN

# /task <id> command
async def cmd_task_by_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    args = context.args
    if not args:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /task <id>")
        return
    try:
        tid = int(args[0])
    except ValueError:
        await update.message.reply_text("ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
        return
    c.execute("SELECT * FROM tasks WHERE id=?", (tid,))
    row = c.fetchone()
    if not row:
        await update.message.reply_text("–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", reply_markup=kb_main_menu())
        return
    # reuse open logic: mimic a CallbackQuery-like response by sending same text & files
    _, user_id, ttype, client, order_number, description, address, deadline, status, avr_json, solution = row
    lines = []
    lines.append(f"üÜî <b>–ó–∞–¥–∞—á–∞ #{tid}</b>")
    lines.append(f"üìå <b>–¢–∏–ø:</b> {'üöó –í—ã–µ–∑–¥–Ω–∞—è' if ttype == 'field' else 'üìù –û–±—â–∞—è'}")
    if client: lines.append(f"üè¢ <b>–ö–ª–∏–µ–Ω—Ç:</b> {client}")
    if order_number: lines.append(f"‚Ññ <b>–ó–∞—è–≤–∫–∏:</b> {order_number}")
    if description: lines.append(f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> {description}")
    if address:
        lines.append(f"üìç <b>–ê–¥—Ä–µ—Å:</b> {address}")
        lines.append(f"üîó <a href='https://yandex.ru/maps/?text={quote_plus(address)}'>–û—Ç–∫—Ä—ã—Ç—å –≤ –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç–∞—Ö</a>")
    lines.append(f"‚è∞ <b>–°—Ä–æ–∫:</b> {deadline}")
    lines.append(f"üìä <b>–°—Ç–∞—Ç—É—Å:</b> {'‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞' if status == 'done' else 'üïí –ê–∫—Ç–∏–≤–Ω–∞'}")
    if status == "done" and solution:
        lines.append(f"üõ† <b>–†–µ—à–µ–Ω–∏–µ:</b> {solution}")
    await update.message.reply_text("\n".join(lines), parse_mode="HTML", disable_web_page_preview=True, reply_markup=kb_main_menu())
    # send files if any
    if avr_json:
        try:
            avr_list = json.loads(avr_json)
            for f in avr_list:
                path = f.get("path"); name = f.get("name")
                if path and os.path.isfile(path):
                    try:
                        await update.message.reply_document(document=InputFile(path, filename=name), caption=f"üìé {name}")
                    except Exception:
                        try:
                            await update.message.reply_document(open(path, "rb"), caption=f"üìé {name}")
                        except Exception:
                            logger.exception("Failed to send file %s", path)
        except Exception:
            logger.exception("Failed to parse avr_json for /task")
    return

# generic callback router to dispatch based on prefix
async def generic_callback_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    data = update.callback_query.data
    # create flows
    if data in ("new", "current", "history", "help_task", "back_main"):
        return await main_menu_callback(update, context)
    if data in ("type_general", "type_field", "back_main"):
        return await choose_type_callback(update, context)
    if data.startswith("client_"):
        return await field_client_callback(update, context)
    if data.startswith("open_"):
        return await open_task_callback(update, context)
    if data.startswith("delete_"):
        return await delete_task_callback(update, context)
    if data.startswith("confirm_delete_"):
        return await confirm_delete_callback(update, context)
    if data.startswith("complete_") or data.startswith("close_") or data.startswith("complete_"):
        # accommodate different callback naming
        # prefer 'complete_' entrypoints
        return await complete_start_callback(update, context)
    if data.startswith("avr_done_"):
        return await avr_done_callback(update, context)
    if data == "hist_date" or data == "hist_search" or data == "history_back":
        return await history_menu_callback(update, context)
    if data.startswith("hist_year_"):
        return await history_year_callback(update, context)
    if data.startswith("hist_month_"):
        return await history_month_callback(update, context)
    if data.startswith("hist_day_"):
        return await history_day_callback(update, context)
    if data.startswith("hist_"):
        # open history detail
        return await history_detail_callback_by_id(update, context)
    # unknown
    await update.callback_query.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞")

# history detail from hist_... (open historical task id)
async def history_detail_callback_by_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data  # hist_<id>
    try:
        tid = int(data.split("_",1)[1])
    except Exception:
        await query.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π ID")
        return S_MAIN
    # re-use open handler by modifying callback.data to open_<id> and calling open_task_callback
    # but simpler: query the DB and send similar output
    c.execute("SELECT * FROM tasks WHERE id=?", (tid,))
    row = c.fetchone()
    if not row:
        await query.message.reply_text("–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return S_MAIN
    _, user_id, ttype, client, order_number, description, address, deadline, status, avr_json, solution = row
    lines = []
    lines.append(f"üÜî <b>–ó–∞–¥–∞—á–∞ #{tid}</b>")
    lines.append(f"üìå <b>–¢–∏–ø:</b> {'üöó –í—ã–µ–∑–¥–Ω–∞—è' if ttype == 'field' else 'üìù –û–±—â–∞—è'}")
    if client: lines.append(f"üè¢ <b>–ö–ª–∏–µ–Ω—Ç:</b> {client}")
    if order_number: lines.append(f"‚Ññ <b>–ó–∞—è–≤–∫–∏:</b> {order_number}")
    if description: lines.append(f"üìù <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> {description}")
    if address:
        lines.append(f"üìç <b>–ê–¥—Ä–µ—Å:</b> {address}")
        lines.append(f"üîó <a href='https://yandex.ru/maps/?text={quote_plus(address)}'>–û—Ç–∫—Ä—ã—Ç—å –≤ –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç–∞—Ö</a>")
    lines.append(f"‚è∞ <b>–°—Ä–æ–∫:</b> {deadline}")
    lines.append(f"üìä <b>–°—Ç–∞—Ç—É—Å:</b> {'‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞' if status == 'done' else 'üïí –ê–∫—Ç–∏–≤–Ω–∞'}")
    if status == "done" and solution:
        lines.append(f"üõ† <b>–†–µ—à–µ–Ω–∏–µ:</b> {solution}")
    await query.message.reply_text("\n".join(lines), parse_mode="HTML", disable_web_page_preview=True, reply_markup=kb_main_menu())
    # files
    if avr_json:
        try:
            avr_list = json.loads(avr_json)
            for f in avr_list:
                path = f.get("path"); name = f.get("name")
                if path and os.path.isfile(path):
                    try:
                        await query.message.reply_document(document=InputFile(path, filename=name), caption=f"üìé {name}")
                    except Exception:
                        try:
                            await query.message.reply_document(open(path, "rb"), caption=f"üìé {name}")
                        except Exception:
                            logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–∞–π–ª %s", path)
        except Exception:
            logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ AVR")
    return S_MAIN

# catch text messages depending on state groups
async def text_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Determine which conversation state we're in using ConversationHandler state or user_data
    # This router handles: general desc, field order, address, desc, deadline, solution, history search input
    # We'll check update.message.chat.type etc.
    # Use message text to route based on last ConversationHandler state via context.user_data keys or conversation state machine
    # Priority: solution_receive (if awaiting solution), field flows, general desc, history search
    if context.user_data.get("state_manual") == "await_solution":
        # handle solution text
        return await solution_receive(update, context)

    # If in field creation steps: check presence of keys
    # If user started creating a field and we expect order:
    if context.user_data.get("creating_type") == "field" and "order_number" not in context.user_data:
        return await field_order_receive(update, context)
    if context.user_data.get("creating_type") == "field" and "order_number" in context.user_data and "client" not in context.user_data:
        # shouldn't happen: client chosen by callback; but if user typed, ignore
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∏–µ–Ω—Ç–∞ –∫–Ω–æ–ø–∫–æ–π.")
        return S_FIELD_CLIENT
    if context.user_data.get("creating_type") == "field" and "client" in context.user_data and "address" not in context.user_data:
        return await field_address_receive(update, context)
    if context.user_data.get("creating_type") == "field" and "address" in context.user_data and "description" not in context.user_data:
        return await field_desc_receive(update, context)
    if context.user_data.get("creating_type") == "field" and "description" in context.user_data and "deadline" not in context.user_data:
        return await field_deadline_receive(update, context)

    # If creating general
    if context.user_data.get("creating_type") == "general" and "description" not in context.user_data:
        return await general_desc_receive(update, context)

    # If awaiting AVR files (manual state)
    if context.user_data.get("state_manual") == "await_avr":
        return await avr_file_receive(update, context)

    # If awaiting history search input
    # We'll check if last called state was S_HISTORY_SEARCH_INPUT using a flag in user_data
    if context.user_data.get("awaiting_history_search"):
        # handle history search
        # clear flag
        context.user_data.pop("awaiting_history_search", None)
        return await history_search_input(update, context)

    # fallback
    await update.message.reply_text("–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –≤ –º–µ–Ω—é.", reply_markup=kb_main_menu())
    return S_MAIN

# register handlers and start
def main():
    if TOKEN == "–í–°–¢–ê–í–¨_–°–í–û–ô_–¢–û–ö–ï–ù" or not TOKEN:
        raise SystemExit("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–ø–∏—à–∏—Ç–µ —Ç–æ–∫–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π TOKEN –≤ –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞.")

    app = Application.builder().token(TOKEN).build()

    # ConversationHandler main entry is /start
    conv = ConversationHandler(
        entry_points=[CommandHandler("start", start_handler)],
        states={
            S_MAIN: [
                CallbackQueryHandler(main_menu_callback, pattern="^(new|current|history|help_task|back_main)$")
            ],
            S_NEW_TYPE: [
                CallbackQueryHandler(choose_type_callback, pattern="^(type_general|type_field|back_main)$")
            ],
            S_GENERAL_DESC: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, general_desc_receive)
            ],
            S_FIELD_ORDER: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, field_order_receive)
            ],
            S_FIELD_CLIENT: [
                CallbackQueryHandler(field_client_callback, pattern="^client_")
            ],
            S_FIELD_ADDRESS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, field_address_receive)
            ],
            S_FIELD_DESC: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, field_desc_receive)
            ],
            S_FIELD_DEADLINE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, field_deadline_receive)
            ],
            S_COMPLETE_AVR: [
                MessageHandler((filters.Document.ALL | filters.PHOTO) & ~filters.COMMAND, avr_file_receive),
                CallbackQueryHandler(avr_done_callback, pattern=r"^avr_done_\d+$")
            ],
            S_COMPLETE_SOLUTION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, solution_receive)
            ],
            S_HISTORY_MENU: [
                CallbackQueryHandler(history_menu_callback, pattern="^(hist_date|hist_search|back_main|history_back)$")
            ],
            S_HISTORY_YEAR: [
                CallbackQueryHandler(history_year_callback, pattern=r"^hist_year_\d{4}$")
            ],
            S_HISTORY_MONTH: [
                CallbackQueryHandler(history_month_callback, pattern=r"^hist_month_\d{4}_\d{1,2}$")
            ],
            S_HISTORY_DAY: [
                CallbackQueryHandler(history_day_callback, pattern=r"^hist_day_\d{4}_\d{1,2}_\d{1,2}$")
            ],
            S_HISTORY_SEARCH_INPUT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, history_search_input)
            ],
        },
        fallbacks=[CommandHandler("start", start_handler)],
        allow_reentry=True
    )

    # register conversation
    app.add_handler(conv)

    # generic callback router for actions not in conv state patterns (open/delete/etc)
    app.add_handler(CallbackQueryHandler(generic_callback_router, pattern=".*"))

    # /task command
    app.add_handler(CommandHandler("task", cmd_task_by_id))

    # run
    logger.info("Bot starting...")
    app.run_polling(allowed_updates=["message", "callback_query", "document", "photo"])

if __name__ == "__main__":
    main()
